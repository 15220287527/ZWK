iOS面试问题

对象的ISA指针指向  
atomic和nonatomic的区别
KVO实现原理
+load和+initialize的区别 
Block类型、变量捕获机制
weak和assign区别
runtime使用场景、消息发送机制 
message send如果找不到对象，后续会做哪些处理
线程同步方案
RunLoop和线程的关系、线程保活
HTTPS请求过程、加密方式
TCP三次握手
什么情况下会出现循环引用，有哪些方式解决NSTimer循环引用问题
APP启动时间如何优化、卡顿优化、卡顿检测
列表视图滑动优化有哪些方法
UIView和CALayer有什么区别
讲讲MVC、MVVM的区别

setState


类和结构体有什么区别
什么是可选型
有哪几种访问权限






通用技能
-----------

**1、你在单元测试方面有过经验吗？UI测试呢？如果你曾使用过任何框架来帮助测试，也提一下。**
[答案](https://www.jianshu.com/p/9707ff30e567)

**2、Scoket连接和HTTP连接的区别**
区别：
HTTP协议是基于TCP连接的，是应用层协议，主要解决如何包装数据。Socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们才能使用TCP/IP协议。
HTTP连接：短连接，客户端向服务器发送一次请求，服务器响应后连接断开，节省资源。服务器不能主动给客户端响应（除非采用HTTP长连接技术），iPhone主要使用类NSURLConnection。
Socket连接：长连接，客户端跟服务器端直接使用Socket进行连接，没有规定连接后断开，因此客户端和服务器段保持连接通道，双方可以主动发送数据，一般多用于游戏.Socket默认连接超时时间是30秒，默认大小是8K（理解为一个数据包大小）。

**3、TCP连接的三次握手**
第一次握手：客户端发送 syn 包(syn=j)到服务器，并进入 SYN_SEND 状态，等待服务器确认；
第二次握手：服务器收到 syn 包，必须确认客户的 SYN（ack=j+1），同时自己也发送一个 SYN 包（syn=k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态；
第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入 ESTABLISHED 状态，完成三次握手。
握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP 连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。断开连接时服务器和客户端均可以主动发起断开 TCP 连接的请求，断开过程需要经过“四次握手”（过程就不细写了，就是服务器和客户端交互，最终确定断开）

**4、在一个HTTPS连接的网站里，输入账号密码点击登录后，到服务器返回这个请求前，中间经历了什么？**
1、客户端打包请求。包括url，端口，你的账号密码等等。账号密码登陆应该用的是Post方式，所以相关的用户信息会被加载到body里面。这个请求应该包含三个方面：网络地址，协议，资源路径。注意，这里是HTTPS，就是HTTP + SSL / TLS，在HTTP上又加了一层处理加密信息的模块（相当于是个锁）。这个过程相当于是客户端请求钥匙。

2、服务器接受请求。一般客户端的请求会先发送到DNS服务器。 DNS服务器负责将你的网络地址解析成IP地址，这个IP地址对应网上一台机器。这其中可能发生Hosts Hijack和ISP failure的问题。过了DNS这一关，信息就到了服务器端，此时客户端会和服务器的端口之间建立一个socket连接，socket一般都是以file descriptor的方式解析请求。这个过程相当于是服务器端分析是否要向客户端发送钥匙模板。

3、服务器端返回数字证书。服务器端会有一套数字证书（相当于是个钥匙模板），这个证书会先发送给客户端。这个过程相当于是服务器端向客户端发送钥匙模板。

4、客户端生成加密信息。根据收到的数字证书（一般内置了证书），客户端会生成钥匙，并把内容锁上，此时信息已经加密。这个过程相当于客户端生成钥匙并锁上请求。

5、客户端发送加密信息。服务器端会收到由自己发送出去的数字证书加锁的信息。 这个时候生成的钥匙也一并被发送到服务器端。这个过程是相当于客户端发送请求。

6、服务器端解锁加密信息。服务器端收到加密信息后，会根据得到的钥匙进行解密，并把要返回的数据进行对称加密。这个过程相当于服务器端解锁请求、生成、加锁回应信息。

7、服务器端向客户端返回信息。客户端会收到相应的加密信息。这个过程相当于服务器端向客户端发送回应。

8、客户端解锁返回信息。客户端会用刚刚生成的钥匙进行解密，将内容显示在浏览器上。

===== 

1.客户端向服务器发起HTTPS的请求，连接到服务器的443端口；

2.服务器将非对称加密的公钥以证书的形式回传给客户端

3.客户端接受到该公钥后进行验证，就是验证步骤2中服务器返回的证书，如果有问题，则HTTPS请求无法继续；如果没有问题，则上述公钥是合格的，客户端这个时候随机生成一个密钥，称为client key(客户端密钥)，即用于对称加密数据的密钥，然后使用前面的公钥对client key进行非对称加密成密文，至此，HTTPS中的第一次HTTP请求结束。

4.客户端发起第二次HTTP请求，将加密之后的client key发送给服务器；

5.服务器使用私钥进行解密，得到解密后的client key，然后使用client key对数据进行对称加密；

6.将对称加密后的数据发送给客户端，客户端收到后对密文进行对称解密，得到服务器发送的数据，这样HTTPS中的第二次HTTP请求结束。HTTPS请求完成。



**5、App启动过慢，你可能想到的因素有哪些？**
[答案](https://www.jianshu.com/p/998f06517eba)

**6、我们应该如何处理后台操作**
[答案](https://blog.csdn.net/qq_32385309/article/details/51698223?t=1511102735139)

**7、到目前为止，你参与过哪些项目？都用到了哪些技术？你就详细讲讲某些有趣的项目，谈谈这些项目用的是什么技术和框架就可以。**  
  
   
   
  
算法题二选一
-----------
**1、给定一个字符串，输出其中只出现一次并且最靠前的那个字符的位置**
    
    public int FirstNotRepeatingChar(String str) {  
        if(str==null||"".equals(str))
            return -1;
        Map<Character,Integer> map = new HashMap<Character,Integer>();
        Set<Character> keys = map.keySet();
        for(int i=0;i<str.length();i++){
            char c = str.charAt(i);
            if(keys.contains(c)){
                int value = map.get(c).intValue();
                value++;
                map.put(c, value);
            }else{
                map.put(c,1);
            }
        }
        for(int i=0;i<str.length();i++){
            char c = str.charAt(i);
            if(map.get(c).intValue()==1)
                return i;
        }
        return -1;
    }

**2、 给定一个整数数组nums，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和**
示例 
1.	输入：nums = [-2,1,-3,4,-1,2,1,-5,4] 输出：6, 连续子数组[4, -1, 2, 1]
2.	输入：nums = [0] 输出：0
3.	输入：nums = [-100] 输出：-100

算法一: 穷举遍历,比较找出最大的
算法二： 不需要计算每一次子序列和,采用累加方式,一步步找出最大值



